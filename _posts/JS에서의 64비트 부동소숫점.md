# JS에서의 64비트 부동소숫점

>  JavaScript Numbers are Always 64-bit Floating Point



자바스크립트는 `Number` 데이터를 담을때 C, JAVA 와 달리 Interer Type(int, short, long, float, double)이 따로 있지 않고, 그냥 `var` 에 담는다. 그리고 JS에서의 number 는 **항상** 64비트 부동소숫점 형식으로 저장된다.

부동소숫점 야야기를 먼저 시작하긴 했지만, 그전에 먼저 숫자에 대해서 생각해보자. 우리가 사용하는 숫자에는 크게 2가지 타입이 있다. 정수와 실수말이다. 우리가 사는 세상에 있는 모든 수는 실수로 나타낼 수 있고, 따라서 정수는 실수의 부분집합이 된다.

컴퓨터는 비트에 담긴 0과1을 사용해서 이진법으로 숫자를 표현하기 때문에 표현할 수 있는 숫자의 개수는 비트 수에 정비례한다. “유한개”인 표현방법으로 “무한개” 인 모든 수(실수)를 표현할 수 없기 때문에, 우리는 정확도를 낮추는 대신 표현할 수 있는 범위를 넓히는 방향을 택한다.

IEEE754에 정의된 스펙에는 실수형을 표현하는 방법에는 2가지가 있다. *single precision* 과 *double precision* 이 그것인데, 두 방법은 비트 수만 제외하고 전부 동일하기 때문에 JS에서 사용하는 *double precision* 에 대해서만 살펴보면 된다.

![img](https://miro.medium.com/max/648/1*3BQhsOh0bXtZ8Mg3bnuOwg.png)



*double precision*은 64비트를 가지고 실수를 표현하는 방법이다. 위 그림과 같이 *sign*(부호) 가 1bit / *exponent*(지수)가 11bit / *fraction*(가수)이 52bit 를 사용한다. 각 부분의 범위를 살펴보면 아래와 같다.

> \- sign는 +1 또는 -1
> \- exponential은 2¹¹-1 = 2047
> \- fraction은 2⁵² -1

부호를 제외하면, 위 숫자로 나타낼 수 있는 범위는

![img](https://miro.medium.com/max/450/1*EZGy650SWjXIxYghgfPz3Q.png)

이다. (**지수부의 -1024는 (-)1024 ~ (+)1024를 만들어 주기 위한 *bias***)

지금 지금부터 실수가 어떻게 정규화 되어 *double precision*으로 표현되는지 살펴보자.

1. 1592.125(10)을 이진수로 표현하면, 11000111000.001(2)이다.
2. *double precision*으로 표현하기 위해 (1.*fraction*) *2^n형태로 정규화한다.
3. 위에 따라 소숫점을 뒤로 옮겨 주면 1.1000111000001(2) * 2¹⁰ 으로 나타낼수 있다.
4. 이를 비트로 표현하면 아래와 같이 된다. (지수부에 *bias* 더한다)
   1 / 100 0000 1010 / 0… 11000111000001
   (*sign* / *exponential* / *fraction*)



## 자바스크립트에서 안전한 수의 범위란 ?

위에서 본 것처럼, 자바스크립트에서 표현할 수 있는 가장 큰 수는 2¹⁰²⁴(약 10³⁰⁸) 이다. 하지만 이것은 표현할 수 있는 가장 큰 수일 뿐, 0부터 2¹⁰²⁴ 까지 모두 표현이 가능한 것은 아니다. 이유는 서두에 말한 것 처럼 *“정확도를 낮추는 대신 표현할 수 있는 범위를 넓히는 방향을 택…”* 했기 때문이다.



## 안전한 정수의 범위는 어떻게 정해질까?

편의상 음의 부호를 제외하고 양의 부호만 사용해서 안전한 정수의 범위를 판단해보자. 가장 작은 정수는 ‘1’ 이다. 그리고 그 다음으로 작은 정수는 ‘2’ 이고, 그 다음은 ‘3’ 이다. 다시말하면 ‘1’ 씩 증가한다고 볼 수 있다. ‘1’ 부터 시작해서 작은 정수순서대로 *double precision* 으로 표현해보자.

> *표기법은 아래를 따른다.
> N :(1.*fraction*) \* 2^n
> (정수) : (2진수) \*(10진수)*

1 : (1.0) * 2⁰
2: (1.0) * 2¹
3: (1.1) * 2¹
4: (1.0) * 2²
…
…
2⁵³ -2: (1.1111……1110)*2⁵³ -2
2⁵³ -1: (1.1111……1111)*2⁵³ -1
2⁵³ : (1.0)*2⁵³
2⁵³+1 : ?

여기서 부터 문제가 발생한다. 2⁵³까지는 ‘1’씩 증가가 가능했는데, 64비트 부동소숫점으로 2⁵³+1을 표현 할 수 있을까? 된다면 무엇이고, 안된다면 다음 큰 수는 무엇이 될까?

첫번째 질문의 정답은 **부동소숫점으로 표현이 불가능**이다. 2⁵³ + 1 은 표현이 불가능하다. 그래서 자바스트립트(ES6)의 `Number`객체에 정의되어 있는, **안전하게 표현할 수 있는 최대의 정수**인 `Number.MAX_SAFE_INTEGER`는 값이 `2⁵³ - 1` 이다. (왜 2⁵³ 이 아니고 2⁵³-1 인지는 아래에서...)

두번째 질문인 다음으로 큰 수는 무엇일까? 다음으로 큰 수는
1.0000……0001 * 2⁵³ 인 2⁵³+2 이고, 그보다 큰수는
1.0000……0010 * 2⁵³ 인 2⁵³+4 이고, 그보다 큰수는
1.0000……0011 * 2⁵³ 인 `2⁵³ +6` 이다.

다시말하면 `2⁵³이상부터는 ‘1’씩 증가되지 않기 때문에 정수의 대소비교는 가능하지만 연산을 보장할 수 없다`.

추가로 왜 2⁵³ 이 아니고 2⁵³ -1 이냐면, 2⁵³ 부터는 ‘1’씩 증가하지 않기 때문에 아래와 같은 상황이 생긴다. 때문에 2⁵³-1이 안전한 최대의 정수가 된다.

```
Number.MAX_SAFE_INTEGER === Math.pow(2,53) - 1 // true
Number.MAX_SAFE_INTEGER === Number.MAX_SAFE_INTEGER + 1 // false
Number.MAX_SAFE_INTEGER +1 === Number.MAX_SAFE_INTEGER + 2 // true
```



## 자바스크립트에서 표현할 수 있는 최대 값은 무엇일까?

*double precison*의 표현형태를 보면 직관적으로 알 수 있듯이 모든 부분을 가장 크게 하면 된다. 부호는 양으로, 지수는 최대로, *fraction* 은 모두 1로! 그러면 아래와 같은 식을 볼 수 있다.

![img](https://miro.medium.com/max/1014/1*AsxKsCJXmT_KzcAwu7aQuQ.png)

1.1111…1111 은 근사치로 2와 같다.

2¹⁰²⁴는 약 10³⁰⁸ 정도 된다. 이 값은 자바스트립트(ES1)에서 `Number` 객체에 있는 `Number.MAX_VALUE` 값과 동일하다.

지금까지 자바스크립트에서 사용하는 Number type의 변수가 64bit 부동소숫점으로 표현되면서 일어나는 일들에 대해 알아보았다. 그리고 예상하건대 부동소숫점을 사용하는 다른 언어들도 위와 마찬가지의 문제를 안고 있을 것이라 생각이 되었다.